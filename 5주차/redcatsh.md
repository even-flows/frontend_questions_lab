### 5주차 Question Lab

### 📣 주제

1. 즉시 호출 함수 표현식이란?
2. 다음 코드가 즉시 호출 함수 표현식(IIFE)로 동작하지 않는 이유에 관해서 설명해보세요: function foo(){ }();<br/>
IIFE로 만들기 위해서는 어떻게 해야 하나요?
3. JavaScript를 디버깅할 때 사용하는 도구가 있으면 설명해주세요. 

---

## 1. 즉시 호출 함수표현식이란?

> "Immediately Invoked Function Expression"의 줄임말로, 함수를 정의하고 즉시 호출하는 JavaScript의 패턴이다. 이는 함수를 정의하고 실행하는 동시에 함수 스코프를 생성하여 변수의 충돌을 방지하고 코드를 모듈화하는 데 도움이 된다. IIFE는 함수 리터럴을 괄호로 둘러싸고 즉시 호출하는 형태로 작성된다.

- 즉시 호출 함수(즉시 실행 함수)의 기본 문법:

```js
(function () {
  // 로직 작성,,,
})();
```
- 화살표 함수를 이용한 IIFE
```js
(() => {
  // 로직 작성,,,
})();
```

- IIFE 내부에 인자 전달하기:
```js
(function (name) {
  console.log('하이, ' + name);
})('송희');
```

- IIFE에서 반환값 활용하기
```js
let result = (function () {
  let message = '하이하이';
  return message;
})();

console.log(result); // '하이하이'
```

---

### 💎 IIFE의 장점

**1. 변수 충돌 방지**

IIFE를 사용하여 변수와 함수를 캡슐화하면 IIFE 내부에서 선언된 변수와 함수는 IIFE의 스코프 내에서만 유효하다. 이로 인해 전역 스코프 오염을 방지하고 다른 코드와의 변수 충돌을 피할 수 있다. 이는 큰 프로젝트에서 특히 유용하며, 코드의 예측 가능성과 안정성을 높인다.

**2. 모듈화와 은닉화** 

IIFE를 사용하면 코드를 모듈화할 수 있다. IIFE 내부에서 정의된 변수와 함수는 외부에서 접근할 수 없으므로, 정보 은닉과 캡슐화를 구현할 수 있다. 이를 통해 모듈 단위로 코드를 구성하고 외부에 노출시키지 않고 내부의 로직을 안전하게 유지할 수 있다.

**3. 초기화 코드 실행**

IIFE는 선언되자마자 즉시 실행되는 특성을 가지고 있다. 이는 초기화 코드를 실행하는 데 사용할 수 있다. 예를 들어, 전역적인 설정이나 초기화 작업을 IIFE 내부에서 처리하면, 코드 실행 직후에 초기화가 이루어져 안정적인 환경을 구축할 수 있다.

**4. 전역 네임스페이스 관리**

IIFE를 사용하면 전역 네임스페이스의 오염을 방지할 수 있다. IIFE 내부에서 변수와 함수를 선언하면 전역 스코프를 오염시키지 않고 필요한 변수와 함수만을 사용할 수 있다. 이는 다른 개발자들과의 협업 시 충돌 가능성을 줄이고 코드의 격리성을 유지하는 데 도움이 된다.

*네임스페이스: 내부식별자(형식, 함수, 변수 등의 이름)에 범위를 제공하는 선언적 영역

---

### ✔️ IIFE의 목적

> IIFE는 외부에서 접근할 수 없는 자체 Scope를 형성한다. IIFE 함수는 상위 Scope에 접근할 수 있으면서도, 내부 변수를 외부로부터 보호해 Privacy를 유지할 수 있다. 따라서 IIFE 사용의 가장 큰 목적은 데이터 프라이버시와 코드 모듈화라고 할 수 있다.

#### 💻 예제 코드:

```js
(function () {
  let score = Math.random() * 10;
  console.log(score >= 5);
})();

console.log(score)       //Uncaught ReferenceError: score is not defined
```
이처럼 외부에서는 내부 변수에 접근하는 것이 불가능하기 때문에 보통 Global scope를 오염시키지 않기 위해 사용하는 경우가 많다.

---

### 🚨 IIFE의 단점

**1. 가독성**

IIFE는 코드의 블록을 즉시 실행하므로 코드의 흐름을 파악하기 어려울 수 있다. 특히 IIFE 내부에서 긴 코드 블록이나 복잡한 로직을 다루는 경우, 코드의 가독성이 저하될 수 있다. 

**2. 디버깅 어려움** 

IIFE 내부의 코드는 즉시 실행되므로 디버깅 중에 해당 코드 블록을 건너뛰기 어려울 수 있다. 디버깅 도구에서 IIFE 내부의 코드를 단계별로 실행하려면 추가적인 작업이 필요할 수 있다. 이는 디버깅 프로세스를 복잡하게 만들 수 있다.

**3. 메모리 사용**

IIFE는 함수를 선언하고 즉시 실행하므로, 함수의 인스턴스가 추가로 생성된다. 이는 메모리 사용을 약간 더 요구하게 될 수 있다. 특히 IIFE를 반복적으로 사용하는 경우, 메모리 소비가 증가할 수 있으며 이는 성능에 영향을 미칠 수 있다.

**4. 모듈 시스템의 등장**

최근 JavaScript에서는 모듈 시스템이 발전하고 널리 사용되고 있다. 모듈 시스템을 사용하면 코드를 모듈화하고 재사용할 수 있으며, 의존성 관리와 네임스페이스 충돌 방지 등을 보다 간편하게 처리할 수 있다. 따라서 IIFE의 사용 빈도가 상대적으로 줄어들고 있다.

---

## 2. function foo(){ }();

#### 💻 예제 코드:

`function foo(){ }();` 이 함수가 IIFE로 동작하지 않는 이유는 해당 함수가 `함수 선언(function declaration)` 으로 작성되었기 때문이다. 
IIFE는 `함수 표현식(function expression)` 으로 작성되어야 한다!

```js
// 일반 함수 선언식 
function foo() {
  console.log("IIFE를 실행하세여");
}
foo();
```

```js
// IIFE (함수 전체를 괄호로 감싸기)
(function foo() {
    console.log("IIFE를 실행하세여");
})();
```

```js
// IIFE (첫 괄호 없이, 마지막에 괄호 추가)
(function foo() {
    console.log("IIFE를 실행하세여");
}());
```

---

## 3. JavaScript를 디버깅할 때 사용하는 도구

**1. Chrome Devtools (Sources 탭)**

원하는 곳에 breakpoint(중단점)을 걸어서 디버깅한다.

 **F10**: 다음행으로 이동<br/>
 **F8**: 다음 breakpoint로 이동

![image](https://github.com/user-attachments/assets/45f0f640-6de3-4464-acd2-28dcb949a4ab)

**2. debugger 명령어 사용**

코드 사이에 debugger 명령어를 입력하면 입력한 곳이 breakpoint이 된다. 코드 실행이 멈추면 실행 단계마다 어떤 일이 일어나는지 추적할 수 있다.

![image](https://github.com/user-attachments/assets/889ced57-d125-4d6f-be29-9a91578c7679)



