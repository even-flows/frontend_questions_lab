# 즉시호출함수(Immediately Invoked Function Expression)
> 정의되자마자 즉시 실행되는 함수로써, 다음과 같이 소괄호(())로 함수를 감싸서 실행하는 문법을 사용한다. 화살표함수로도 표현 가능하다. 즉시실행함수에도 이름을 붙여 기명 즉시실행함수로 사용 할 수 있다. 하지만 즉시실행함수는 선언과 동시에 호출되어 반환되어 재사용 할 수 없기 때문에 이름을 지어주는 것이 의미가 없다.
> 플러그인이나 라이브러리 등을 만들 때 많이 사용된다
> 또한 아래와같이 즉시호출함수(IIFE)는 전체 익명함수를 괄호로 감싸줌으로써 내부 코드가 선언문이 아니라 표현식인 것처럼 Parser를 속인다.
> function 키워드가 코드의 시작 부분에 오면, 자바스크립트는 이를 기본적으로 함수 선언문으로 해석한다. 하지만 괄호로 감싸면 자바스크립트는 값을 반환하는 표현식으로 해석하게 다.
```javascript
(function () {
    console.log("IIFE");
})();

(() => {
    console.log("IIFE");
})();
```
## 즉시 실행함수의 표현식 종류
1. 논리 부정 연산자
> !undefiend는 true를 반환하기 때문에 바로실행된다. 하지만 리턴값이 없어야한다.
```javascript
!function() {
	console.log("바로실행");
}();
```
3. 괄호 안에서 괄호 문법
```javascript
(function() {
  console.log('괄호안에서 괄호 문법');
})();
```
5. Douglas 표기법
> 1번 논리 부정 연산자와 괄호 위치의 차이가있다.
```javascript
(function() {
  console.log('더글라스 표현식');
}());
```
## 즉시실행함수를 사용하는 이유

1. 필요없는 전역 변수의 생성을 줄일 수 있다. 함수를 생성하면 그 함수는 전역 변수로써 남아있게 되고, 많은 변수의 생성은 전역 스코프를 오염시킬 수 있다.

- 즉시실행함수를 선언하면 내부 변수가 전역으로 저장되지 않기 때문에 전역 스코프의 오염을 줄일 수 있다.

2. private한 변수를 만들 수 있다.
- 즉시실행함수는 외부에서 접근 할 수 없는 자체적인 스코프를 가지게된다. 이는 클로저의 사용 목적과도 비슷하며 내부 변수를 외부로부터 private하게 보호 할 수 있다는 장점이 있다.

3.async await 비동기처리 바로 사용
- await 키워드는 반드시 async function 내에서 쓸수 있다는 제한 때문에 반드시 함수를 정의하고 함수를 호출하는 형식으로 사용하여야 한다.
- 하지만 모든 코드를 함수로 묶고 호출하는 방식은 가독성 측면에서 좋지 않을 수 있다.
- 따라서 만일 이를 별도의 함수 호출이 아닌 일반 코드 실행과 같이 즉시 실행을 하고 싶은 경우 다음과 같이 async function을 정의하고 즉시 호출하기도 한다. 이는 정말 자주 사용되는 기법 이기도 하다.
```javascript
(async () => {
  ... async로 처리될 내용들 blabla
  await promise();
  ... blabla
})();
```

## 괄호뒤에 세미콜론을 붙여야하는이유
-  괄호 앞에 세미콜론이 없다면, 자바스크립트 엔진은 괄호를 함수 호출이 아니라 연산자 우선순위를 조절하는 역할로 해석해 버린다.
잘못된 예시
```javascript
 var x = function () {
 } 
 
 (function () {
 	console.log('헬로헬로')
 })()
```

# 다음 코드가 즉시 호출 함수 표현식(IIFE)로 동작하지 않는 이유에 관해서 설명해보세요: function foo(){ }();. IIFE로 만들기 위해서는 어떻게 해야 하나요?
> 위에 말했듯 괄호로 감싸지지않았기 때문이다.내부 코드가 선언문이 아니라 표현식인 것처럼 Parser를 속이지못했기 떄문# 즉시호출함수(Immediately Invoked Function Expression)
> 정의되자마자 즉시 실행되는 함수로써, 다음과 같이 소괄호(())로 함수를 감싸서 실행하는 문법을 사용한다. 화살표함수로도 표현 가능하다. 즉시실행함수에도 이름을 붙여 기명 즉시실행함수로 사용 할 수 있다. 하지만 즉시실행함수는 선언과 동시에 호출되어 반환되어 재사용 할 수 없기 때문에 이름을 지어주는 것이 의미가 없다.
> 플러그인이나 라이브러리 등을 만들 때 많이 사용된다
> 또한 아래와같이 즉시호출함수(IIFE)는 전체 익명함수를 괄호로 감싸줌으로써 내부 코드가 선언문이 아니라 표현식인 것처럼 Parser를 속인다.
```javascript
(function () {
    console.log("IIFE");
})();

(() => {
    console.log("IIFE");
})();
```
## 즉시 실행함수의 표현식 종류
1. 논리 부정 연산자
> !undefiend는 true를 반환하기 때문에 바로실행된다. 하지만 리턴값이 없어야한다.
```javascript
!function() {
	console.log("바로실행");
}();
```
3. 괄호 안에서 괄호 문법
```javascript
(function() {
  console.log('괄호안에서 괄호 문법');
})();
```
5. Douglas 표기법
> 1번 논리 부정 연산자와 괄호 위치의 차이가있다.
```javascript
(function() {
  console.log('더글라스 표현식');
}());
```
## 즉시실행함수를 사용하는 이유

1. 필요없는 전역 변수의 생성을 줄일 수 있다. 함수를 생성하면 그 함수는 전역 변수로써 남아있게 되고, 많은 변수의 생성은 전역 스코프를 오염시킬 수 있다.

- 즉시실행함수를 선언하면 내부 변수가 전역으로 저장되지 않기 때문에 전역 스코프의 오염을 줄일 수 있다.

2. private한 변수를 만들 수 있다.
- 즉시실행함수는 외부에서 접근 할 수 없는 자체적인 스코프를 가지게된다. 이는 클로저의 사용 목적과도 비슷하며 내부 변수를 외부로부터 private하게 보호 할 수 있다는 장점이 있다.

3.async await 비동기처리 바로 사용
- await 키워드는 반드시 async function 내에서 쓸수 있다는 제한 때문에 반드시 함수를 정의하고 함수를 호출하는 형식으로 사용하여야 한다.
- 하지만 모든 코드를 함수로 묶고 호출하는 방식은 가독성 측면에서 좋지 않을 수 있다.
- 따라서 만일 이를 별도의 함수 호출이 아닌 일반 코드 실행과 같이 즉시 실행을 하고 싶은 경우 다음과 같이 async function을 정의하고 즉시 호출하기도 한다. 이는 정말 자주 사용되는 기법 이기도 하다.
```javascript
(async () => {
  ... async로 처리될 내용들 blabla
  await promise();
  ... blabla
})();
```

## 괄호뒤에 세미콜론을 붙여야하는이유
-  괄호 앞에 세미콜론이 없다면, 자바스크립트 엔진은 괄호를 함수 호출이 아니라 연산자 우선순위를 조절하는 역할로 해석해 버린다.
잘못된 예시
```javascript
 var x = function () {
 } 
 
 (function () {
 	console.log('헬로헬로')
 })()
```

# 다음 코드가 즉시 호출 함수 표현식(IIFE)로 동작하지 않는 이유에 관해서 설명해보세요: function foo(){ }();. IIFE로 만들기 위해서는 어떻게 해야 하나요?
> 위에 말했듯 괄호로 감싸지지않았기 때문이다.내부 코드가 선언문이 아니라 표현식인 것처럼 Parser를 속이지못했기 떄문
> 아래와 같이 만들면된다.

```javascript
(function foo() {})();
```
# JavaScript를 디버깅할 때 사용하는 도구가 있으면 설명해주세요. 
## 크롬 디버거
![image](https://github.com/user-attachments/assets/e297897e-e2b8-4931-949e-5a3bc120bc39)

각 버튼들의 역할
1. Step: 다음 명령어 실행

다음 디버거를 만날 때까지 스크립트 실행을 계속한다. 디버거가 더 이상 없으면, 나머지 스크립트를 실행하고 끝난다.

2. Step Over: 다음 명령어를 실행하되, 함수 안으로 들어가진 않음

Step은 함수 내부로 진입해 함수 본문 첫 번째 줄에서 실행을 멈추는 반면, Step Over는 함수를 실행하지만, 함수 내로 진입하진 않는다.
실행은 함수 실행이 끝난 후, 즉시 멈춘다. 함수 호출 시 내부에서 어떤 일이 일어나는지 궁금하지 않을 때 유용하다.

3. Step Into: 함수로 진입해 모든 작업을 한 줄씩 검사

Step은 비동기 동작은 무시하는 반면, Step into는 비동기 동작을 담당하는 코드로 진입하고, 필요하다면 비동기 동작이 완료될 때까지 대기한다.

4. Step Out: 함수를 검사하고 해당 함수를 호출하는 라인으로 돌아감

현재 실행 중인 함수의 실행을 계속 이어가다가 함수 본문 마지막 줄에서 실행을 멈춘다. 빨리 함수 실행을 끝내고 싶은 경우에 사용한다.

5. 모든 중단점(breakpoint)을 활성화/비활성화
모든 중단점을 일시적으로 활성화/비활성화한다(실행에는 영향이 없다).

6.예외 발생 시 코드를 자동 중지시켜주는 기능을 활성화/비활성화
활성화되어 있고, 개발자 도구가 열려있는 상태에서 스크립트 실행 중에 에러가 발생하면 실행이 자동으로 멈춘다. 실행이 중단되었기 때문에 변수 등을 조사해 어디서 에러가 발생했는지 찾을 수 있다. 개발하다가 에러와 함께 스크립트가 죽었다면 디버거를 열고 이 옵션을 활성화한 후, 페이지를 새로 고침하면 에러가 발생한 곳과 에러 발생 시점의 컨텍스트를 확인할 수 있다.

## VSCODE
![image](https://github.com/user-attachments/assets/f105c781-8bd4-417c-8cf3-e1cf367b390b)
